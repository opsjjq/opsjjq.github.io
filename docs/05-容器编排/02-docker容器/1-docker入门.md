# Docker 入门与架构指南

## 一、什么是容器化技术

容器共享主机内核，具有**轻量、隔离且高效**的特点。与传统虚拟机不同，容器不需要运行完整的操作系统，而是直接运行在宿主机内核之上，实现进程级的资源隔离。

### 容器基本架构

<img src="./assets/image-20260208232717478.png" alt="image-20260208232717478" style="zoom: 50%;" />

- **上层**：多个容器（App A~F），每个容器独立运行一个应用。
- **中间层**：Docker 引擎，负责容器的创建、管理和运行。
- **底层**：主机操作系统（Host OS）与基础设施，为容器提供硬件与系统支持。

---

### Docker 与虚拟机的架构区别

| 特性 | 虚拟机 | Docker 容器 |
| :--- | :--- | :--- |
| 隔离级别 | 硬件级别虚拟化 | 操作系统级别虚拟化 |
| 操作系统 | 每个 VM 需要完整 OS | 共享宿主机 OS 内核 |
| 资源占用 | 重量级，占用较多资源 | 轻量级，资源占用少 |
| 启动时间 | 分钟级别 | 秒级别 |
| 性能开销 | 较大 | 接近原生性能 |
| 镜像大小 | GB 级别 | MB 级别 |

---

## 二、为什么要学容器化技术 Docker？

### 1. 传统应用部署的痛点

- **环境不一致**：开发、测试、生产环境差异导致应用行为不可预测。
- **依赖管理复杂**：不同应用需要不同版本的运行时、库文件，易冲突。
- **资源利用率低**：虚拟机需要完整操作系统，资源消耗大。
- **部署复杂**：手动配置环境易出错，部署流程繁琐。

---

### 2. 容器化技术的解决方案

- **环境标准化**：将应用及其依赖打包成镜像，确保环境一致性。
- **轻量级**：共享宿主机内核，无需完整操作系统。
- **快速部署**：秒级启动，提升部署效率。
- **可移植性**：一次构建，到处运行。

---

### 3. 容器化的核心理念

遵循"不可变基础设施"理念：

- 应用与环境打包为不可变镜像。
- 每次部署使用相同镜像。
- 配置通过环境变量或外部文件注入。
- 修复问题通过重建镜像而非修改运行中容器。

---

### Docker 核心技术概念

#### 1. 镜像（Image）

> 只读模板，包含运行应用所需的所有内容：代码、运行时、库、环境变量与配置。

**特点**：

- 分层存储，每层代表一次修改
- 只读不可直接修改
- 可复用，支持版本管理（通过标签）

**类比理解**：镜像就像安装程序或模板，定义了运行环境，但不能直接运行。

---

#### 2. 容器（Container）

> 镜像的运行实例，是一个轻量级、可移植的执行环境。

**特点**：

- 隔离性：拥有独立的文件系统、网络与进程空间
- 临时性：可创建、启动、停止、删除
- 可写层：在镜像基础上添加一个可写层
- 进程级：通常运行一个主进程

**类比理解**：如果镜像是"类"，容器就是"对象实例"。

---

#### 3. 仓库（Repository）

> 存储和分发镜像的地方，可包含一个镜像的多个版本。

**分类**：

- 公共仓库：如 Docker Hub
- 私有仓库：企业内部搭建
- 官方仓库：由软件官方维护

**Registry vs Repository**：

- **Registry**：仓库服务器，如 Docker Hub
- **Repository**：具体镜像仓库，如 `nginx`、`mysql`

---

## 三、为什么选择 Docker？

### 主要优势

#### 1. 更高效的资源利用

- 无需完整操作系统，共享宿主机内核
- 资源占用少，性能接近原生
- 支持高密度部署

---

#### 2. 更快的启动时间

- 秒级启动，支持快速扩缩容
- 故障恢复迅速

---

#### 3. 一致性的环境

- 开发、测试、生产环境完全一致
- Dockerfile 定义完整运行环境
- 依赖隔离，避免冲突

---

#### 4. 持续交付与部署

- 镜像是标准化交付物
- 可与 CI/CD 工具无缝集成
- 环境版本化，易于追溯

```text
CI/CD 集成流程：
代码提交 → 自动构建镜像 → 自动化测试 → 推送镜像 → 自动部署
```

---

#### 5. 更轻松的迁移

- 平台无关，支持跨物理机、虚拟机、云环境运行
- 简化跨云迁移与环境复制

---

### Docker 应用场景

```text
1. 微服务架构
   - 服务独立容器化
   - 支持独立部署与扩展
   - 技术栈自由选择

2. CI/CD 流水线
   - 标准化构建环境
   - 测试环境隔离
   - 部署一致性保障

3. 开发环境标准化
   - 快速搭建开发环境
   - 团队环境同步
   - 避免本地依赖冲突

4. 应用现代化
   - 传统应用容器化改造
   - 云迁移与混合云部署
```

---

## 四、Docker 架构与组件

![image-20260208233046077](./assets/image-20260208233046077.png)

### 核心组件

#### 1. Docker Client

用户通过命令行（CLI）与 Docker 守护进程交互的工具。

**常用命令**：

```bash
docker run    # 运行容器
docker build  # 构建镜像
docker pull   # 拉取镜像
docker ps     # 查看容器状态
```

---

#### 2. Docker Daemon

Docker 的核心服务进程，负责管理镜像、容器、网络与存储卷，并监听 Docker API 请求。

**主要职责**：

- 镜像管理（构建、存储、分发）
- 容器生命周期管理
- 网络与数据卷管理
- 与 Registry 通信

---

#### 3. Docker Engine API

由 Docker Client、Docker Daemon 与 REST API 组成，是 Docker 的核心运行组件。

**工作流程**：

```text
Client → Daemon → Registry → 返回结果
```

---

#### 4. Docker Registry

用于存储和分发 Docker 镜像的服务，支持公有与私有部署。

**Docker Hub**：官方公共仓库，包含大量预构建镜像，支持自动化构建。

---

## 五、扩展知识

### 相关技术概念

```text
OpenStack
- 云管理平台，本身不提供虚拟化
- 通过底层 Hypervisor（如 KVM）实现虚拟化
- 提供 Web 界面管理虚拟机、网络与资源

KVM
- Linux 虚拟化核心技术
- 通过 QEMU-KVM 提供完整的虚拟化能力
- 通常由 libvirt 进行管理

Docker 的诞生
- 基于 Linux 容器技术（LXC）
- 由 dotCloud 公司开发并开源
- 旨在简化容器的创建与管理

Hypervisor
- 运行在物理服务器与操作系统之间的虚拟化层
- 常见如 VMware ESXi、Hyper-V、XenServer

Container Runtime
- 通过 Linux 内核虚拟化能力管理容器
- 容器共享宿主机内核，资源占用少
```

---

### Namespace：资源隔离的核心

> Namespace 是 Linux 内核功能，用于隔离系统资源，使不同容器拥有独立的进程、网络、文件系统等环境。

#### Docker 使用的 6 种 Namespace

| 类型 | 作用 | 应用场景 |
| :--- | :--- | :--- |
| PID | 隔离进程 ID | 容器内进程独立 |
| Network | 隔离网络设备、IP、端口 | 每个容器拥有独立网络栈 |
| Mount | 隔离文件系统挂载点 | 容器只能看到自己的文件系统 |
| UTS | 隔离主机名与域名 | 容器可自定义 hostname |
| IPC | 隔离进程间通信 | 避免容器间通信干扰 |
| User | 隔离用户与用户组 | 容器内可使用独立 UID/GID |
