# Kubernetes（K8s）安装与核心组件详解

> ① 参考资料汇总
> ② 核心组件详解
> ③ 集群安装步骤
> ④ 常见工具与网络插件配置

---

## 0. 参考资料

```text
1. k8s能干什么
https://kubernetes.io/zh-cn/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do

2. Docker 官方文档
https://docs.docker.com/get-started/

3. kubeadm 创建 k8s 集群（官方）
https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/

4. Prometheus 监控系统
https://prometheus.io/docs/introduction/overview/

5. Ansible 部署 k8s 工具（easzlab/kubeasz）
https://github.com/easzlab/kubeasz

6. 阿里云 k8s 产品（生产环境推荐）
https://www.aliyun.com/product/kubernetes

7. 多版本 K8s API 查询工具
https://k8s.mybatis.io/v1.19/

8. YAML 自动生成工具
https://k8syaml.com/

9. 华为云 Kubernetes 文档
https://support.huaweicloud.com/basics-cce/kubernetes_0003.html
```

---

## 一、核心组件详解

### 控制平面组件（Control Plane / Master）

#### 1. etcd

集群的"数据库"

- 分布式、高可用的 **KV 数据库**
- 保存 **整个集群的最终状态**（Node、Pod、Service、Deployment 等）
- **所有组件通过 API Server 与 etcd 间接协作**

> 记忆点：**"K8s 没有 etcd，就等于没有记忆"**

---

#### 2. apiserver

集群的唯一入口

- Kubernetes 的 **统一访问入口**
- 所有操作都必须经过它：kubectl、Controller、Scheduler、kubelet
- 主要职责：
  - 认证（Authentication）
  - 授权（Authorization）
  - 准入控制（Admission）
  - API 注册与发现

> 记忆点：**"谁都不能绕过 API Server"**

---

#### 3. controller-manager

集群的"纠偏系统"

- 核心思想：**不断让"实际状态"逼近"期望状态"**
- 内部包含多个 Controller，例如：
  - Replication Controller：保证副本数
  - Node Controller：节点状态管理
  - Service / Endpoints Controller
  - ResourceQuota Controller

> 记忆点：**"集群出问题，Controller 来兜底"**

---

#### 4. scheduler

调度决策者

- **只负责一件事**：把 Pod 调度到合适的 Node
- 调度依据：
  - 资源情况（CPU / 内存）
  - 亲和 / 反亲和规则
  - 污点与容忍策略
- **Scheduler 只做决策，不创建 Pod、不运行容器**

> 记忆点：**"Scheduler 只动脑，不动手"**

---

### 工作节点组件（Node）

#### 5. kubelet

Node 上的"执行者"

- 运行在每一台 Node 上的 **代理进程**
- 核心职责：
  - **Pod 生命周期管理**（从 API Server 获取期望状态，调用 CRI 创建/删除容器）
  - **容器健康检查**（执行 liveness / readiness 探针）
  - **资源监控**（通过 cAdvisor 采集信息并上报）
  - **对接插件**（存储：CSI / Volume；网络：CNI）

> 记忆点：**"Pod 是 kubelet 真正养大的"**

---

#### 6. Container Runtime

真正跑容器的组件

- 负责镜像管理、容器创建、启动、销毁
- 通过 **CRI（Container Runtime Interface）** 与 kubelet 通信
- 常见实现：
  - Docker（旧版本）
  - containerd（主流）
  - CRI-O

> 记忆点：**"kubelet 负责指挥，runtime 负责干活"**

---

#### 7. kube-proxy

Service 的网络实现者

- 负责 **Service 的网络转发与负载均衡**
- 核心功能：将 Service IP 转发到后端 Pod
- 实现方式：iptables 或 ipvs（性能更好）
- **kube-proxy 不是 DNS，只是做网络规则转发**

> 记忆点：**"Service 能访问，全靠 kube-proxy 写规则"**

---

### 客户端工具

#### 8. kubectl

管理入口工具

- Kubernetes 官方 CLI
- 本质：向 kube-apiserver 发送 HTTP 请求
- 常用能力：
  - 资源增删改查
  - 日志查看
  - exec 进入容器

> 记忆点：**"kubectl ≈ API Server 客户端"**

---

### 组件关系一句话总结

> **kubectl / 组件 → API Server → etcd
> Scheduler 决定去哪
> Controller 保证不出错
> kubelet 真正跑 Pod
> kube-proxy 负责网络转发**

---

### 建议记住的五句话

1. **etcd 保存状态**
2. **API Server 是唯一入口**
3. **Controller 保证期望状态**
4. **Scheduler 决定 Pod 去哪**
5. **kubelet 在 Node 上真正干活**

---

## 二、K8s 部署架构概览

```bash
master:
  etcd
  kube-apiserver
  kube-controller-manager
  kube-scheduler
  kubelet
  kube-proxy
  flannel
  containerd
  runc
  CNI

node1 / node2:
  kubelet
  kube-proxy
  flannel
  containerd
  runc
  CNI
  nerdctl
  buildkitd

# 网络插件 flannel 确保三台机器内的容器之间可以互相通信
```

---

## 三、版本选择建议

| 组件 | 版本 | 说明 |
| :--- | :--- | :--- |
| **containerd** | **1.6.39** | 1.6 系列最终维护版，兼容 k8s ≤ 1.27 |
| **runc** | **1.1.12** | 最后一个稳定支持 glibc 2.17 |
| **nerdctl** | **1.7.7** | 官方声明支持 containerd 1.6 |
| **buildkit** | **0.12.5** | 不强依赖新 glibc |
| **CNI plugins** | **v1.2.0** | flannel / kubelet 完全兼容 |

---

## 四、环境准备

```bash
## 主机名解析
cat >> /etc/hosts <<'EOF'
10.0.0.10 k8s-master-10
10.0.0.11 k8s-node-11
10.0.0.12 k8s-node-12
EOF

## 防火墙与 SELinux 初始化
systemctl stop firewalld NetworkManager
systemctl disable firewalld NetworkManager

sed -ri 's#(SELINUX=).*#\1disabled#' /etc/selinux/config
setenforce 0
getenforce

iptables -F
iptables -X
iptables -Z
iptables -P FORWARD ACCEPT

## 关闭 swap（k8s 默认禁用 swap）
swapoff -a
sed -i '/ swap / s|^\(.*\)$|#\1|g' /etc/fstab

## yum 源配置（阿里云镜像）
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
sed -i '/aliyuncs/d' /etc/yum.repos.d/*.repo
yum clean all && yum makecache fast

## 时间同步（chrony）
yum install chrony -y
systemctl start chronyd
systemctl enable chronyd
ntpdate -u ntp.aliyun.com
hwclock -w

## 内核参数配置（开启数据包转发）
cat <<EOF > /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
vm.max_map_count = 262144
EOF
modprobe br_netfilter
sysctl -p /etc/sysctl.d/k8s.conf
```

---

## 五、更新 CentOS 7 系统内核

```bash
mkdir -p /opt/kernel
cd /opt/kernel
wget https://dl.lamp.sh/kernel/el7/kernel-ml-5.10.222-1.el7.x86_64.rpm
wget https://dl.lamp.sh/kernel/el7/kernel-ml-devel-5.10.222-1.el7.x86_64.rpm

yum localinstall -y kernel-ml-5.10.222-1.el7.x86_64.rpm kernel-ml-devel-5.10.222-1.el7.x86_64.rpm

awk -F\' '$1=="menuentry " {print $2}' /etc/grub2.cfg

grub2-set-default 'CentOS Linux (5.10.222-1.el7.x86_64) 7 (Core)'
reboot

# 重启后验证
uname -r
# 输出：5.10.222-1.el7.x86_64
```

---

## 六、安装 containerd

```bash
cd /opt/
wget https://github.com/containerd/containerd/releases/download/v1.6.39/containerd-1.6.39-linux-amd64.tar.gz
tar -xf containerd-1.6.39-linux-amd64.tar.gz
mv /opt/bin/* /usr/local/bin
mkdir -p /etc/containerd
containerd config default > /etc/containerd/config.toml

tee /etc/systemd/system/containerd.service <<'EOF'
[Unit]
Description=containerd container runtime
Documentation=https://containerd.io
After=network.target dbus.service
[Service]
ExecStartPre=-/sbin/modprobe overlay
ExecStart=/usr/local/bin/containerd
Type=notify
Delegate=yes
KillMode=process
Restart=always
RestartSec=5
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
OOMScoreAdjust=-999
[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable containerd

sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml
sed -i 's|sandbox_image = ".*"|sandbox_image = "registry.aliyuncs.com/google_containers/pause:3.9"|' /etc/containerd/config.toml

# 镜像加速配置
mkdir -p /etc/containerd/certs.d/docker.io
cat > /etc/containerd/certs.d/docker.io/hosts.toml <<EOF
server = "https://docker.io"
[host."https://docker.1ms.run"]
  capabilities = ["pull", "resolve"]
EOF

systemctl restart containerd
```

---

## 七、安装 runc

```bash
wget https://github.com/opencontainers/runc/releases/download/v1.1.12/runc.amd64
chmod +x runc.amd64
mv runc.amd64 /usr/local/bin/runc
```

---

## 八、安装 CNI 插件

```bash
mkdir -p /opt/cni/bin
wget https://github.com/containernetworking/plugins/releases/download/v1.2.0/cni-plugins-linux-amd64-v1.2.0.tgz
tar -C /opt/cni/bin -xzf cni-plugins-linux-amd64-v1.2.0.tgz
```

---

## 九、安装 kubelet、kubeadm、kubectl 等

```bash
cat <<EOF > /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF

yum clean all && yum makecache
yum install kubelet-1.27.0 kubeadm-1.27.0 kubectl-1.27.0 ipvsadm cri-tools-1.26.0 -y

systemctl enable kubelet

# crictl 配置
tee /etc/crictl.yaml <<EOF
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
EOF

crictl version
crictl pull alpine
crictl images
```

---

## 十、Master 节点初始化

```bash
kubeadm init \
  --apiserver-advertise-address=10.0.0.10 \
  --image-repository registry.aliyuncs.com/google_containers \
  --kubernetes-version v1.27.0 \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.2.0.0/16 \
  --service-dns-domain=cluster.local \
  --ignore-preflight-errors=Swap \
  --ignore-preflight-errors=NumCPU
```

初始化成功后，按提示执行：

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

---

## 十一、Node 节点加入集群

```bash
# 在 Node 节点执行（token 和 hash 以实际输出为准）
kubeadm join 10.0.0.10:6443 --token <token> \
  --discovery-token-ca-cert-hash sha256:<hash>
```

---

## 十二、安装 Flannel 网络插件

```bash
# 在 Master 节点执行
cd /opt
git clone --depth 1 https://github.com/coreos/flannel.git
cd flannel/Documentation

# 编辑 kube-flannel.yml
# 修改两处：
# 1. Network: "10.2.0.0/16"（与 --pod-network-cidr 一致）
# 2. 在 args 中添加 --iface=eth0

kubectl apply -f kube-flannel.yml
```

---

## 十三、配置 kubectl 补全

```bash
yum install bash-completion -y
source /usr/share/bash-completion/bash_completion
source <(kubectl completion bash)
echo "source <(kubectl completion bash)" >> ~/.bashrc
```

---

## 十四、Master 污点设置（禁止调度）

```bash
kubectl taint nodes k8s-master-10 node-role.kubernetes.io/control-plane=:NoSchedule

# 重启 CoreDNS 使其重新调度到 Node 节点
kubectl -n kube-system rollout restart deploy coredns

# 验证
kubectl -n kube-system get pods -o wide | grep coredns
```

---

## 十五、安装 nerdctl（替代 Docker CLI）

```bash
wget https://github.com/containerd/nerdctl/releases/download/v1.7.7/nerdctl-1.7.7-linux-amd64.tar.gz
tar xf nerdctl-1.7.7-linux-amd64.tar.gz
mv nerdctl /usr/local/bin/

# 设置 docker 别名
cat > /usr/local/bin/docker <<'EOF'
#!/bin/bash
/usr/local/bin/nerdctl "$@"
EOF
chmod +x /usr/local/bin/docker

# 补全配置
nerdctl completion bash > /etc/bash_completion.d/nerdctl
source /etc/bash_completion.d/nerdctl
```

> 关键点：`nerdctl -n k8s.io` 可直接操作 k8s 使用的镜像，无需 push/pull。

---

## 十六、安装 buildkit（镜像构建工具）

```bash
wget https://github.com/moby/buildkit/releases/download/v0.12.5/buildkit-v0.12.5.linux-amd64.tar.gz
mkdir -p /usr/local/buildctl
tar -zxvf buildkit-v0.12.5.linux-amd64.tar.gz -C /usr/local/buildctl

ln -s /usr/local/buildctl/bin/buildkitd /usr/local/bin/buildkitd
ln -s /usr/local/buildctl/bin/buildctl /usr/local/bin/buildctl

tee /etc/systemd/system/buildkit.service <<'EOF'
[Unit]
Description=BuildKit
Documentation=https://github.com/moby/buildkit
[Service]
ExecStart=/usr/local/bin/buildkitd
Restart=always
RestartSec=5
[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable --now buildkit
```

---

## 十七、配置 kube-proxy 使用 IPVS 模式

```bash
kubectl edit configmap -n kube-system kube-proxy

# 修改：
# mode: "" → mode: "ipvs"
# scheduler: "" → scheduler: "rr"

kubectl rollout restart daemonset -n kube-system kube-proxy
```

---

## 十八、测试运行 Pod

```bash
kubectl run nginx-test --image=nginx:latest
kubectl get pods -o wide

# 进入容器执行命令
kubectl exec nginx-test -- sh -c 'echo "Hello K8s!" > /usr/share/nginx/html/index.html'

# 访问 Pod IP（需在同集群内）
curl <Pod-IP>
```

---

## 十九、总结：Master 与 Node 组件分布

```bash
# Master 节点
etcd
kube-apiserver
kube-controller-manager
kube-scheduler
kubelet
kube-proxy
flannel
containerd
runc
CNI 插件

# Node 节点
kubelet
kube-proxy
flannel
containerd
runc
CNI 插件
nerdctl
buildkit
```

---

## 二十、参考资料与延伸阅读

- [腾讯云 K8s 安装文档](https://cloud.tencent.com/developer/article/2307102)
- [CSDN 详细安装指南](https://blog.csdn.net/terryzxy/article/details/141673546)
- [K8s 官方文档](https://kubernetes.io/zh-cn/docs/home/)
- [containerd 官方 GitHub](https://github.com/containerd/containerd)
