# Kubernetes（K8s）开篇

> ① K8s 是什么
> ② K8s 解决什么问题
> ③ 为什么值得去学

---

## 一、学习 K8s 的正确心态

1. 先学会**使用**（安装、部署应用、使用 kubectl）
2. 再逐步理解 **为什么这么设计**（组件、原理）
3. 随着规模扩大，再补齐 **网络、存储、调度、安全** 等知识

---

## 二、为什么需要 Kubernetes

K8s 并不是凭空出现的，它是 **基础架构演进到一定阶段的必然产物**，本质是为了更好地管理和编排容器技术。

### 架构演进历程

#### 阶段一：物理机部署

- 应用直接跑在物理机上
- 资源利用率低、环境不一致、部署和扩展困难

---

#### 阶段二：虚拟化（VMware / OpenStack）

- 提高资源利用率
- 但虚拟机依然重、启动慢、运维复杂、资源开销大

---

#### 阶段三：容器化（Docker）

- 镜像 + 容器，实现环境一致、轻量化
- 启动快、交付快、资源隔离性好

**问题随之而来**：

- 容器多了怎么管理？
- 容器跨主机如何通信？
- 容器挂了谁来拉起？
- 多台机器如何统一调度？
- 如何实现高可用与弹性伸缩？

---

#### 阶段四：容器编排（Kubernetes）

> **Docker 解决了"如何运行一个容器"**
>
> **Kubernetes 解决了"如何在一堆机器上长期、稳定地运行成千上万个容器"**

---

## 三、Kubernetes 到底解决了什么问题

K8s 本质是一个 **容器编排与管理平台**，核心解决以下问题：

1. **应用自动部署**（声明式配置）
2. **容器自动调度**（智能分配资源）
3. **服务自愈**（故障自动恢复与重建）
4. **服务发现与负载均衡**
5. **跨主机容器网络**
6. **配置与密钥管理**
7. **滚动升级与回滚**
8. **资源限制与监控**
9. **自动扩缩容**

一句话总结：

> **你只需要告诉 K8s：我要什么结果，至于怎么做到，交给 K8s。**

---

## 四、K8s 的整体架构认知

### 集群的基本组成

一个 Kubernetes 集群 = **控制平面（Master） + 工作节点（Node）**

---

#### 1. Master（控制平面）

负责：**"管"**

核心组件：

- **api-server**：集群的唯一入口，所有操作都要经过它
- **etcd**：分布式键值存储，保存整个集群的状态数据
- **controller-manager**：运行各种控制器，确保"期望状态 = 实际状态"
- **scheduler**：负责将 Pod 调度到合适的 Node 上
- **kubectl**：命令行客户端工具，用于与集群交互

---

#### 2. Node（工作节点）

负责：**"干活"**

核心组件：

- **kubelet**：Node 上的管家，负责 Pod 的生命周期管理
- **kube-proxy**：实现 Service 网络代理与负载均衡
- **容器运行时**：如 Docker / containerd，负责运行容器
- **kubectl**：同样可安装在 Node 上作为客户端使用（但通常仅在 Master 或本地使用）

---

## 五、K8s 的核心设计思想

### 1. 声明式 API

你不是告诉 K8s：

> "先启动容器 A，再启动容器 B"

而是告诉它：

> "我需要 3 个 nginx 实例一直处于运行状态"

K8s 会不断 **对比"期望状态"和"实际状态"**，并自动修正差异。

---

### 2. 一切皆资源（Resource）

在 K8s 中：

- Pod 是资源
- Node 是资源
- Service 是资源
- ConfigMap / Secret 也是资源

**所有资源都可以用 YAML 描述**，并通过 API Server 统一管理。

---

## 六、Pod：K8s 中最重要的概念

### 什么是 Pod

> **Pod 是 K8s 中运行应用的最小单位，而不是容器。**

一个 Pod：

- 可以包含 **一个或多个容器**
- 容器之间 **共享网络、存储、进程命名空间**
- 通常是临时性的，设计为可被替换和重建

---

### Pod 的关键特性

1. Pod IP **不稳定**（重建就变）
2. Pod 内所有容器 **共享同一个 IP**
3. Pod 天生就是"临时的"
4. Pod 通常不直接创建，而是由 **控制器**（如 Deployment）管理

---

## 七、Pod 是如何被创建的（面试重点）

简化流程：

1. `kubectl` 向 **kube-apiserver** 提交创建请求
2. **Scheduler** 根据资源与策略选择合适的 Node
3. 目标 Node 上的 **kubelet** 监听到任务安排
4. kubelet 调用 **容器运行时** 创建容器
5. **CNI 网络插件** 分配 Pod IP 并设置网络
6. Pod 进入 Running 状态

👉 **记住：所有控制逻辑都在 Master，真正干活的是 Node。**

---

## 八、为什么必须有网络插件（如 Flannel）

K8s 有一个硬性要求：

> **任意两个 Pod 之间，必须可以直接通信（不经过 NAT）**

Docker 默认网络无法实现跨主机 Pod 直连，因此必须使用网络插件，例如：

- Flannel
- Calico
- Weave

网络插件负责：

- Pod IP 分配
- 跨主机网络通信（封装/解封装）
- 维护整个集群的虚拟网络

---

## 九、K8s 入门阶段你真正需要掌握的

### 必会三件事

1. **会安装集群**（如使用 kubeadm）
2. **会用 kubectl**（常用命令：get / describe / exec / logs / apply）
3. **理解 Pod、Node、Service 之间的关系**

---

### 暂时不用死磕的

- Scheduler 调度算法细节
- etcd 内部实现原理
- 各种 CRD（Custom Resource Definition）
- 高级安全策略与网络策略

---

## 十、总结一句话

> **Kubernetes = 一个让容器在大规模集群中"自动、稳定、可控运行"的操作系统。**
