import{_ as s,c as o,e as r,o as n}from"./app-DtXLoKBz.js";const a={};function l(t,e){return n(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="kubernetes-k8s-开篇" tabindex="-1"><a class="header-anchor" href="#kubernetes-k8s-开篇"><span>Kubernetes（K8s）开篇</span></a></h1><blockquote><p>① K8s 是什么 ② K8s 解决什么问题 ③ 为什么值得去学</p></blockquote><hr><h2 id="一、学习-k8s-的正确心态" tabindex="-1"><a class="header-anchor" href="#一、学习-k8s-的正确心态"><span>一、学习 K8s 的正确心态</span></a></h2><ol><li>先学会<strong>使用</strong>（安装、部署应用、使用 kubectl）</li><li>再逐步理解 <strong>为什么这么设计</strong>（组件、原理）</li><li>随着规模扩大，再补齐 <strong>网络、存储、调度、安全</strong> 等知识</li></ol><hr><h2 id="二、为什么需要-kubernetes" tabindex="-1"><a class="header-anchor" href="#二、为什么需要-kubernetes"><span>二、为什么需要 Kubernetes</span></a></h2><p>K8s 并不是凭空出现的，它是 <strong>基础架构演进到一定阶段的必然产物</strong>，本质是为了更好地管理和编排容器技术。</p><h3 id="架构演进历程" tabindex="-1"><a class="header-anchor" href="#架构演进历程"><span>架构演进历程</span></a></h3><h4 id="阶段一-物理机部署" tabindex="-1"><a class="header-anchor" href="#阶段一-物理机部署"><span>阶段一：物理机部署</span></a></h4><ul><li>应用直接跑在物理机上</li><li>资源利用率低、环境不一致、部署和扩展困难</li></ul><hr><h4 id="阶段二-虚拟化-vmware-openstack" tabindex="-1"><a class="header-anchor" href="#阶段二-虚拟化-vmware-openstack"><span>阶段二：虚拟化（VMware / OpenStack）</span></a></h4><ul><li>提高资源利用率</li><li>但虚拟机依然重、启动慢、运维复杂、资源开销大</li></ul><hr><h4 id="阶段三-容器化-docker" tabindex="-1"><a class="header-anchor" href="#阶段三-容器化-docker"><span>阶段三：容器化（Docker）</span></a></h4><ul><li>镜像 + 容器，实现环境一致、轻量化</li><li>启动快、交付快、资源隔离性好</li></ul><p><strong>问题随之而来</strong>：</p><ul><li>容器多了怎么管理？</li><li>容器跨主机如何通信？</li><li>容器挂了谁来拉起？</li><li>多台机器如何统一调度？</li><li>如何实现高可用与弹性伸缩？</li></ul><hr><h4 id="阶段四-容器编排-kubernetes" tabindex="-1"><a class="header-anchor" href="#阶段四-容器编排-kubernetes"><span>阶段四：容器编排（Kubernetes）</span></a></h4><blockquote><p><strong>Docker 解决了&quot;如何运行一个容器&quot;</strong></p><p><strong>Kubernetes 解决了&quot;如何在一堆机器上长期、稳定地运行成千上万个容器&quot;</strong></p></blockquote><hr><h2 id="三、kubernetes-到底解决了什么问题" tabindex="-1"><a class="header-anchor" href="#三、kubernetes-到底解决了什么问题"><span>三、Kubernetes 到底解决了什么问题</span></a></h2><p>K8s 本质是一个 <strong>容器编排与管理平台</strong>，核心解决以下问题：</p><ol><li><strong>应用自动部署</strong>（声明式配置）</li><li><strong>容器自动调度</strong>（智能分配资源）</li><li><strong>服务自愈</strong>（故障自动恢复与重建）</li><li><strong>服务发现与负载均衡</strong></li><li><strong>跨主机容器网络</strong></li><li><strong>配置与密钥管理</strong></li><li><strong>滚动升级与回滚</strong></li><li><strong>资源限制与监控</strong></li><li><strong>自动扩缩容</strong></li></ol><p>一句话总结：</p><blockquote><p><strong>你只需要告诉 K8s：我要什么结果，至于怎么做到，交给 K8s。</strong></p></blockquote><hr><h2 id="四、k8s-的整体架构认知" tabindex="-1"><a class="header-anchor" href="#四、k8s-的整体架构认知"><span>四、K8s 的整体架构认知</span></a></h2><h3 id="集群的基本组成" tabindex="-1"><a class="header-anchor" href="#集群的基本组成"><span>集群的基本组成</span></a></h3><p>一个 Kubernetes 集群 = <strong>控制平面（Master） + 工作节点（Node）</strong></p><hr><h4 id="_1-master-控制平面" tabindex="-1"><a class="header-anchor" href="#_1-master-控制平面"><span>1. Master（控制平面）</span></a></h4><p>负责：<strong>&quot;管&quot;</strong></p><p>核心组件：</p><ul><li><strong>api-server</strong>：集群的唯一入口，所有操作都要经过它</li><li><strong>etcd</strong>：分布式键值存储，保存整个集群的状态数据</li><li><strong>controller-manager</strong>：运行各种控制器，确保&quot;期望状态 = 实际状态&quot;</li><li><strong>scheduler</strong>：负责将 Pod 调度到合适的 Node 上</li><li><strong>kubectl</strong>：命令行客户端工具，用于与集群交互</li></ul><hr><h4 id="_2-node-工作节点" tabindex="-1"><a class="header-anchor" href="#_2-node-工作节点"><span>2. Node（工作节点）</span></a></h4><p>负责：<strong>&quot;干活&quot;</strong></p><p>核心组件：</p><ul><li><strong>kubelet</strong>：Node 上的管家，负责 Pod 的生命周期管理</li><li><strong>kube-proxy</strong>：实现 Service 网络代理与负载均衡</li><li><strong>容器运行时</strong>：如 Docker / containerd，负责运行容器</li><li><strong>kubectl</strong>：同样可安装在 Node 上作为客户端使用（但通常仅在 Master 或本地使用）</li></ul><hr><h2 id="五、k8s-的核心设计思想" tabindex="-1"><a class="header-anchor" href="#五、k8s-的核心设计思想"><span>五、K8s 的核心设计思想</span></a></h2><h3 id="_1-声明式-api" tabindex="-1"><a class="header-anchor" href="#_1-声明式-api"><span>1. 声明式 API</span></a></h3><p>你不是告诉 K8s：</p><blockquote><p>&quot;先启动容器 A，再启动容器 B&quot;</p></blockquote><p>而是告诉它：</p><blockquote><p>&quot;我需要 3 个 nginx 实例一直处于运行状态&quot;</p></blockquote><p>K8s 会不断 <strong>对比&quot;期望状态&quot;和&quot;实际状态&quot;</strong>，并自动修正差异。</p><hr><h3 id="_2-一切皆资源-resource" tabindex="-1"><a class="header-anchor" href="#_2-一切皆资源-resource"><span>2. 一切皆资源（Resource）</span></a></h3><p>在 K8s 中：</p><ul><li>Pod 是资源</li><li>Node 是资源</li><li>Service 是资源</li><li>ConfigMap / Secret 也是资源</li></ul><p><strong>所有资源都可以用 YAML 描述</strong>，并通过 API Server 统一管理。</p><hr><h2 id="六、pod-k8s-中最重要的概念" tabindex="-1"><a class="header-anchor" href="#六、pod-k8s-中最重要的概念"><span>六、Pod：K8s 中最重要的概念</span></a></h2><h3 id="什么是-pod" tabindex="-1"><a class="header-anchor" href="#什么是-pod"><span>什么是 Pod</span></a></h3><blockquote><p><strong>Pod 是 K8s 中运行应用的最小单位，而不是容器。</strong></p></blockquote><p>一个 Pod：</p><ul><li>可以包含 <strong>一个或多个容器</strong></li><li>容器之间 <strong>共享网络、存储、进程命名空间</strong></li><li>通常是临时性的，设计为可被替换和重建</li></ul><hr><h3 id="pod-的关键特性" tabindex="-1"><a class="header-anchor" href="#pod-的关键特性"><span>Pod 的关键特性</span></a></h3><ol><li>Pod IP <strong>不稳定</strong>（重建就变）</li><li>Pod 内所有容器 <strong>共享同一个 IP</strong></li><li>Pod 天生就是&quot;临时的&quot;</li><li>Pod 通常不直接创建，而是由 <strong>控制器</strong>（如 Deployment）管理</li></ol><hr><h2 id="七、pod-是如何被创建的-面试重点" tabindex="-1"><a class="header-anchor" href="#七、pod-是如何被创建的-面试重点"><span>七、Pod 是如何被创建的（面试重点）</span></a></h2><p>简化流程：</p><ol><li><code>kubectl</code> 向 <strong>kube-apiserver</strong> 提交创建请求</li><li><strong>Scheduler</strong> 根据资源与策略选择合适的 Node</li><li>目标 Node 上的 <strong>kubelet</strong> 监听到任务安排</li><li>kubelet 调用 <strong>容器运行时</strong> 创建容器</li><li><strong>CNI 网络插件</strong> 分配 Pod IP 并设置网络</li><li>Pod 进入 Running 状态</li></ol><p>👉 <strong>记住：所有控制逻辑都在 Master，真正干活的是 Node。</strong></p><hr><h2 id="八、为什么必须有网络插件-如-flannel" tabindex="-1"><a class="header-anchor" href="#八、为什么必须有网络插件-如-flannel"><span>八、为什么必须有网络插件（如 Flannel）</span></a></h2><p>K8s 有一个硬性要求：</p><blockquote><p><strong>任意两个 Pod 之间，必须可以直接通信（不经过 NAT）</strong></p></blockquote><p>Docker 默认网络无法实现跨主机 Pod 直连，因此必须使用网络插件，例如：</p><ul><li>Flannel</li><li>Calico</li><li>Weave</li></ul><p>网络插件负责：</p><ul><li>Pod IP 分配</li><li>跨主机网络通信（封装/解封装）</li><li>维护整个集群的虚拟网络</li></ul><hr><h2 id="九、k8s-入门阶段你真正需要掌握的" tabindex="-1"><a class="header-anchor" href="#九、k8s-入门阶段你真正需要掌握的"><span>九、K8s 入门阶段你真正需要掌握的</span></a></h2><h3 id="必会三件事" tabindex="-1"><a class="header-anchor" href="#必会三件事"><span>必会三件事</span></a></h3><ol><li><strong>会安装集群</strong>（如使用 kubeadm）</li><li><strong>会用 kubectl</strong>（常用命令：get / describe / exec / logs / apply）</li><li><strong>理解 Pod、Node、Service 之间的关系</strong></li></ol><hr><h3 id="暂时不用死磕的" tabindex="-1"><a class="header-anchor" href="#暂时不用死磕的"><span>暂时不用死磕的</span></a></h3><ul><li>Scheduler 调度算法细节</li><li>etcd 内部实现原理</li><li>各种 CRD（Custom Resource Definition）</li><li>高级安全策略与网络策略</li></ul><hr><h2 id="十、总结一句话" tabindex="-1"><a class="header-anchor" href="#十、总结一句话"><span>十、总结一句话</span></a></h2><blockquote><p><strong>Kubernetes = 一个让容器在大规模集群中&quot;自动、稳定、可控运行&quot;的操作系统。</strong></p></blockquote>',87)])])}const h=s(a,[["render",l]]),p=JSON.parse('{"path":"/05-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/03-kubernetes%E7%BC%96%E6%8E%92/1-k8s%E5%85%A5%E9%97%A8.html","title":"Kubernetes（K8s）开篇","lang":"zh-CN","frontmatter":{},"git":{"contributors":[{"name":"opsjjq","username":"opsjjq","email":"wangyp987@gmail.com","commits":1,"url":"https://github.com/opsjjq"}],"changelog":[{"hash":"ca8e661b7c6729c958583ed3d1a001b6de398273","time":1771558748000,"email":"wangyp987@gmail.com","author":"opsjjq","message":"222"}]},"filePathRelative":"05-容器编排/03-kubernetes编排/1-k8s入门.md"}');export{h as comp,p as data};
