import{_ as s,c as n,e as a,o as l}from"./app-DtXLoKBz.js";const t="/assets/image-20260208232717478-Br7NSLe8.png",i="/assets/image-20260208233046077-CjXDOJ-n.png",r={};function d(c,e){return l(),n("div",null,[...e[0]||(e[0]=[a('<h1 id="docker-入门与架构指南" tabindex="-1"><a class="header-anchor" href="#docker-入门与架构指南"><span>Docker 入门与架构指南</span></a></h1><h2 id="一、什么是容器化技术" tabindex="-1"><a class="header-anchor" href="#一、什么是容器化技术"><span>一、什么是容器化技术</span></a></h2><p>容器共享主机内核，具有<strong>轻量、隔离且高效</strong>的特点。与传统虚拟机不同，容器不需要运行完整的操作系统，而是直接运行在宿主机内核之上，实现进程级的资源隔离。</p><h3 id="容器基本架构" tabindex="-1"><a class="header-anchor" href="#容器基本架构"><span>容器基本架构</span></a></h3><img src="'+t+`" alt="image-20260208232717478" style="zoom:50%;"><ul><li><strong>上层</strong>：多个容器（App A~F），每个容器独立运行一个应用。</li><li><strong>中间层</strong>：Docker 引擎，负责容器的创建、管理和运行。</li><li><strong>底层</strong>：主机操作系统（Host OS）与基础设施，为容器提供硬件与系统支持。</li></ul><hr><h3 id="docker-与虚拟机的架构区别" tabindex="-1"><a class="header-anchor" href="#docker-与虚拟机的架构区别"><span>Docker 与虚拟机的架构区别</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">虚拟机</th><th style="text-align:left;">Docker 容器</th></tr></thead><tbody><tr><td style="text-align:left;">隔离级别</td><td style="text-align:left;">硬件级别虚拟化</td><td style="text-align:left;">操作系统级别虚拟化</td></tr><tr><td style="text-align:left;">操作系统</td><td style="text-align:left;">每个 VM 需要完整 OS</td><td style="text-align:left;">共享宿主机 OS 内核</td></tr><tr><td style="text-align:left;">资源占用</td><td style="text-align:left;">重量级，占用较多资源</td><td style="text-align:left;">轻量级，资源占用少</td></tr><tr><td style="text-align:left;">启动时间</td><td style="text-align:left;">分钟级别</td><td style="text-align:left;">秒级别</td></tr><tr><td style="text-align:left;">性能开销</td><td style="text-align:left;">较大</td><td style="text-align:left;">接近原生性能</td></tr><tr><td style="text-align:left;">镜像大小</td><td style="text-align:left;">GB 级别</td><td style="text-align:left;">MB 级别</td></tr></tbody></table><hr><h2 id="二、为什么要学容器化技术-docker" tabindex="-1"><a class="header-anchor" href="#二、为什么要学容器化技术-docker"><span>二、为什么要学容器化技术 Docker？</span></a></h2><h3 id="_1-传统应用部署的痛点" tabindex="-1"><a class="header-anchor" href="#_1-传统应用部署的痛点"><span>1. 传统应用部署的痛点</span></a></h3><ul><li><strong>环境不一致</strong>：开发、测试、生产环境差异导致应用行为不可预测。</li><li><strong>依赖管理复杂</strong>：不同应用需要不同版本的运行时、库文件，易冲突。</li><li><strong>资源利用率低</strong>：虚拟机需要完整操作系统，资源消耗大。</li><li><strong>部署复杂</strong>：手动配置环境易出错，部署流程繁琐。</li></ul><hr><h3 id="_2-容器化技术的解决方案" tabindex="-1"><a class="header-anchor" href="#_2-容器化技术的解决方案"><span>2. 容器化技术的解决方案</span></a></h3><ul><li><strong>环境标准化</strong>：将应用及其依赖打包成镜像，确保环境一致性。</li><li><strong>轻量级</strong>：共享宿主机内核，无需完整操作系统。</li><li><strong>快速部署</strong>：秒级启动，提升部署效率。</li><li><strong>可移植性</strong>：一次构建，到处运行。</li></ul><hr><h3 id="_3-容器化的核心理念" tabindex="-1"><a class="header-anchor" href="#_3-容器化的核心理念"><span>3. 容器化的核心理念</span></a></h3><p>遵循&quot;不可变基础设施&quot;理念：</p><ul><li>应用与环境打包为不可变镜像。</li><li>每次部署使用相同镜像。</li><li>配置通过环境变量或外部文件注入。</li><li>修复问题通过重建镜像而非修改运行中容器。</li></ul><hr><h3 id="docker-核心技术概念" tabindex="-1"><a class="header-anchor" href="#docker-核心技术概念"><span>Docker 核心技术概念</span></a></h3><h4 id="_1-镜像-image" tabindex="-1"><a class="header-anchor" href="#_1-镜像-image"><span>1. 镜像（Image）</span></a></h4><blockquote><p>只读模板，包含运行应用所需的所有内容：代码、运行时、库、环境变量与配置。</p></blockquote><p><strong>特点</strong>：</p><ul><li>分层存储，每层代表一次修改</li><li>只读不可直接修改</li><li>可复用，支持版本管理（通过标签）</li></ul><p><strong>类比理解</strong>：镜像就像安装程序或模板，定义了运行环境，但不能直接运行。</p><hr><h4 id="_2-容器-container" tabindex="-1"><a class="header-anchor" href="#_2-容器-container"><span>2. 容器（Container）</span></a></h4><blockquote><p>镜像的运行实例，是一个轻量级、可移植的执行环境。</p></blockquote><p><strong>特点</strong>：</p><ul><li>隔离性：拥有独立的文件系统、网络与进程空间</li><li>临时性：可创建、启动、停止、删除</li><li>可写层：在镜像基础上添加一个可写层</li><li>进程级：通常运行一个主进程</li></ul><p><strong>类比理解</strong>：如果镜像是&quot;类&quot;，容器就是&quot;对象实例&quot;。</p><hr><h4 id="_3-仓库-repository" tabindex="-1"><a class="header-anchor" href="#_3-仓库-repository"><span>3. 仓库（Repository）</span></a></h4><blockquote><p>存储和分发镜像的地方，可包含一个镜像的多个版本。</p></blockquote><p><strong>分类</strong>：</p><ul><li>公共仓库：如 Docker Hub</li><li>私有仓库：企业内部搭建</li><li>官方仓库：由软件官方维护</li></ul><p><strong>Registry vs Repository</strong>：</p><ul><li><strong>Registry</strong>：仓库服务器，如 Docker Hub</li><li><strong>Repository</strong>：具体镜像仓库，如 <code>nginx</code>、<code>mysql</code></li></ul><hr><h2 id="三、为什么选择-docker" tabindex="-1"><a class="header-anchor" href="#三、为什么选择-docker"><span>三、为什么选择 Docker？</span></a></h2><h3 id="主要优势" tabindex="-1"><a class="header-anchor" href="#主要优势"><span>主要优势</span></a></h3><h4 id="_1-更高效的资源利用" tabindex="-1"><a class="header-anchor" href="#_1-更高效的资源利用"><span>1. 更高效的资源利用</span></a></h4><ul><li>无需完整操作系统，共享宿主机内核</li><li>资源占用少，性能接近原生</li><li>支持高密度部署</li></ul><hr><h4 id="_2-更快的启动时间" tabindex="-1"><a class="header-anchor" href="#_2-更快的启动时间"><span>2. 更快的启动时间</span></a></h4><ul><li>秒级启动，支持快速扩缩容</li><li>故障恢复迅速</li></ul><hr><h4 id="_3-一致性的环境" tabindex="-1"><a class="header-anchor" href="#_3-一致性的环境"><span>3. 一致性的环境</span></a></h4><ul><li>开发、测试、生产环境完全一致</li><li>Dockerfile 定义完整运行环境</li><li>依赖隔离，避免冲突</li></ul><hr><h4 id="_4-持续交付与部署" tabindex="-1"><a class="header-anchor" href="#_4-持续交付与部署"><span>4. 持续交付与部署</span></a></h4><ul><li>镜像是标准化交付物</li><li>可与 CI/CD 工具无缝集成</li><li>环境版本化，易于追溯</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">CI/CD 集成流程：</span>
<span class="line">代码提交 → 自动构建镜像 → 自动化测试 → 推送镜像 → 自动部署</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="_5-更轻松的迁移" tabindex="-1"><a class="header-anchor" href="#_5-更轻松的迁移"><span>5. 更轻松的迁移</span></a></h4><ul><li>平台无关，支持跨物理机、虚拟机、云环境运行</li><li>简化跨云迁移与环境复制</li></ul><hr><h3 id="docker-应用场景" tabindex="-1"><a class="header-anchor" href="#docker-应用场景"><span>Docker 应用场景</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">1. 微服务架构</span>
<span class="line">   - 服务独立容器化</span>
<span class="line">   - 支持独立部署与扩展</span>
<span class="line">   - 技术栈自由选择</span>
<span class="line"></span>
<span class="line">2. CI/CD 流水线</span>
<span class="line">   - 标准化构建环境</span>
<span class="line">   - 测试环境隔离</span>
<span class="line">   - 部署一致性保障</span>
<span class="line"></span>
<span class="line">3. 开发环境标准化</span>
<span class="line">   - 快速搭建开发环境</span>
<span class="line">   - 团队环境同步</span>
<span class="line">   - 避免本地依赖冲突</span>
<span class="line"></span>
<span class="line">4. 应用现代化</span>
<span class="line">   - 传统应用容器化改造</span>
<span class="line">   - 云迁移与混合云部署</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="四、docker-架构与组件" tabindex="-1"><a class="header-anchor" href="#四、docker-架构与组件"><span>四、Docker 架构与组件</span></a></h2><p><img src="`+i+`" alt="image-20260208233046077"></p><h3 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件"><span>核心组件</span></a></h3><h4 id="_1-docker-client" tabindex="-1"><a class="header-anchor" href="#_1-docker-client"><span>1. Docker Client</span></a></h4><p>用户通过命令行（CLI）与 Docker 守护进程交互的工具。</p><p><strong>常用命令</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">docker</span> run    <span class="token comment"># 运行容器</span></span>
<span class="line"><span class="token function">docker</span> build  <span class="token comment"># 构建镜像</span></span>
<span class="line"><span class="token function">docker</span> pull   <span class="token comment"># 拉取镜像</span></span>
<span class="line"><span class="token function">docker</span> <span class="token function">ps</span>     <span class="token comment"># 查看容器状态</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="_2-docker-daemon" tabindex="-1"><a class="header-anchor" href="#_2-docker-daemon"><span>2. Docker Daemon</span></a></h4><p>Docker 的核心服务进程，负责管理镜像、容器、网络与存储卷，并监听 Docker API 请求。</p><p><strong>主要职责</strong>：</p><ul><li>镜像管理（构建、存储、分发）</li><li>容器生命周期管理</li><li>网络与数据卷管理</li><li>与 Registry 通信</li></ul><hr><h4 id="_3-docker-engine-api" tabindex="-1"><a class="header-anchor" href="#_3-docker-engine-api"><span>3. Docker Engine API</span></a></h4><p>由 Docker Client、Docker Daemon 与 REST API 组成，是 Docker 的核心运行组件。</p><p><strong>工作流程</strong>：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Client → Daemon → Registry → 返回结果</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h4 id="_4-docker-registry" tabindex="-1"><a class="header-anchor" href="#_4-docker-registry"><span>4. Docker Registry</span></a></h4><p>用于存储和分发 Docker 镜像的服务，支持公有与私有部署。</p><p><strong>Docker Hub</strong>：官方公共仓库，包含大量预构建镜像，支持自动化构建。</p><hr><h2 id="五、扩展知识" tabindex="-1"><a class="header-anchor" href="#五、扩展知识"><span>五、扩展知识</span></a></h2><h3 id="相关技术概念" tabindex="-1"><a class="header-anchor" href="#相关技术概念"><span>相关技术概念</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">OpenStack</span>
<span class="line">- 云管理平台，本身不提供虚拟化</span>
<span class="line">- 通过底层 Hypervisor（如 KVM）实现虚拟化</span>
<span class="line">- 提供 Web 界面管理虚拟机、网络与资源</span>
<span class="line"></span>
<span class="line">KVM</span>
<span class="line">- Linux 虚拟化核心技术</span>
<span class="line">- 通过 QEMU-KVM 提供完整的虚拟化能力</span>
<span class="line">- 通常由 libvirt 进行管理</span>
<span class="line"></span>
<span class="line">Docker 的诞生</span>
<span class="line">- 基于 Linux 容器技术（LXC）</span>
<span class="line">- 由 dotCloud 公司开发并开源</span>
<span class="line">- 旨在简化容器的创建与管理</span>
<span class="line"></span>
<span class="line">Hypervisor</span>
<span class="line">- 运行在物理服务器与操作系统之间的虚拟化层</span>
<span class="line">- 常见如 VMware ESXi、Hyper-V、XenServer</span>
<span class="line"></span>
<span class="line">Container Runtime</span>
<span class="line">- 通过 Linux 内核虚拟化能力管理容器</span>
<span class="line">- 容器共享宿主机内核，资源占用少</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="namespace-资源隔离的核心" tabindex="-1"><a class="header-anchor" href="#namespace-资源隔离的核心"><span>Namespace：资源隔离的核心</span></a></h3><blockquote><p>Namespace 是 Linux 内核功能，用于隔离系统资源，使不同容器拥有独立的进程、网络、文件系统等环境。</p></blockquote><h4 id="docker-使用的-6-种-namespace" tabindex="-1"><a class="header-anchor" href="#docker-使用的-6-种-namespace"><span>Docker 使用的 6 种 Namespace</span></a></h4><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">作用</th><th style="text-align:left;">应用场景</th></tr></thead><tbody><tr><td style="text-align:left;">PID</td><td style="text-align:left;">隔离进程 ID</td><td style="text-align:left;">容器内进程独立</td></tr><tr><td style="text-align:left;">Network</td><td style="text-align:left;">隔离网络设备、IP、端口</td><td style="text-align:left;">每个容器拥有独立网络栈</td></tr><tr><td style="text-align:left;">Mount</td><td style="text-align:left;">隔离文件系统挂载点</td><td style="text-align:left;">容器只能看到自己的文件系统</td></tr><tr><td style="text-align:left;">UTS</td><td style="text-align:left;">隔离主机名与域名</td><td style="text-align:left;">容器可自定义 hostname</td></tr><tr><td style="text-align:left;">IPC</td><td style="text-align:left;">隔离进程间通信</td><td style="text-align:left;">避免容器间通信干扰</td></tr><tr><td style="text-align:left;">User</td><td style="text-align:left;">隔离用户与用户组</td><td style="text-align:left;">容器内可使用独立 UID/GID</td></tr></tbody></table>`,92)])])}const o=s(r,[["render",d]]),h=JSON.parse('{"path":"/05-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/02-docker%E5%AE%B9%E5%99%A8/1-docker%E5%85%A5%E9%97%A8.html","title":"Docker 入门与架构指南","lang":"zh-CN","frontmatter":{},"git":{"contributors":[{"name":"opsjjq","username":"opsjjq","email":"wangyp987@gmail.com","commits":1,"url":"https://github.com/opsjjq"}],"changelog":[{"hash":"ca8e661b7c6729c958583ed3d1a001b6de398273","time":1771558748000,"email":"wangyp987@gmail.com","author":"opsjjq","message":"222"}]},"filePathRelative":"05-容器编排/02-docker容器/1-docker入门.md"}');export{o as comp,h as data};
